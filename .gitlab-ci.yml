image: node:12.14.1-alpine

stages:
  - install_dependencies
  - build
  - push-docker-image
  - migration
  - deploy

variables:
  DOCKER_DRIVER: overlay

install_dependencies:
  stage: install_dependencies
  script:
    - npm install
  cache:
    key: ${CI_COMMIT_REF_SLUG}
    paths:
      - node_modules/
  artifacts:
    paths:
      - node_modules/
  only:
    changes:
      - package-lock.json

build:
  stage: build
  image: docker:19.03.5-git
  services:
    - docker:19.03.5-dind
  before_script:
    - >
      if [ ! -f buildx-v0.3.1.linux-amd64 ]; then
        wget -q https://github.com/docker/buildx/releases/download/v0.3.1/buildx-v0.3.1.linux-amd64;
        chmod 777 buildx-v0.3.1.linux-amd64;
      fi
  script:
    - mkdir -p ~/.docker/cli-plugins/;
    - cp buildx-v0.3.1.linux-amd64 ~/.docker/cli-plugins/docker-buildx
    - docker buildx create --name mybuilder --use
    - docker buildx ls
    - mkdir -p cache
    - ls cache
    - >
      if [ -d cache ]; then
        echo 'using cache';
        docker buildx build --cache-from=./cache --cache-to=type=local,dest=./cache -t app .
      else
        docker buildx build --cache-to=type=local,dest=./cache -t app .
      fi
    - docker save app > image.tar
  dependencies: []
  cache:
    key: docker-image-cache
    paths:
      - cache/
      - buildx-v0.3.1.linux-amd64
  artifacts:
    paths:
      - app.tar

test:
  stage: build
  cache:
    key: ${CI_COMMIT_REF_SLUG}
    paths:
      - node_modules/
    policy: pull
  script:
    - npm run test

lint:
  stage: build
  cache:
    key: ${CI_COMMIT_REF_SLUG}
    paths:
      - node_modules/
    policy: pull
  script:
    - npm run lint:ci

push-docker-image:
  stage: push-docker-image
  image: docker:19.03.5-git
  services:
    - docker:19.03.5-dind
  dependencies: []
  before_script:
    - docker login -u gitlab-ci-token -p $CI_BUILD_TOKEN registry.gitlab.com
    - DOCKER_TAG=$([ "$CI_COMMIT_REF_NAME" == "master" ] && echo "staging-b$CI_PIPELINE_ID" || echo "production-b$CI_PIPELINE_ID")
  script:
    - docker load < image.tar
    - docker image tag app:latest $CI_REGISTRY_IMAGE:$DOCKER_TAG
    - docker push $CI_REGISTRY_IMAGE:$DOCKER_TAG
  only:
    - master
    - production

migration-staging:
  stage: migration
  dependencies: []
  before_script:
    - npm install
  script:
    - npm run typeorm:run
  environment:
    name: staging
  only:
    - master

migration-production:
  stage: migration
  dependencies: []
  before_script:
    - npm install
  script:
    - npm run typeorm:run
  environment:
    name: production
  when: manual
  only:
    - production

deploy-staging:
  stage: deploy
  image: coxauto/aws-ebcli
  dependencies: []
  script:
    - apk --no-cache add gettext
    - git checkout -B "$CI_BUILD_REF_NAME" "$CI_BUILD_REF"
    - cd eb
    - cat Dockerrun.aws.json.template | envsubst > Dockerrun.aws.json
    - git add Dockerrun.aws.json
    - eb deploy --staged
    - cd ../ && EXIT_STATUS=$? scripts/to_slack.sh
  variables:
    ENVIRONMENT: staging
    APP_VERSION: "staging-b$CI_PIPELINE_ID"
    GIT_STRATEGY: clone
  environment:
    name: staging
    url: https://staging.tastie.me
  only:
    - master

deploy-production:
  stage: deploy
  image: coxauto/aws-ebcli
  dependencies: []
  script:
    - apk --no-cache add gettext
    - git checkout -B "$CI_BUILD_REF_NAME" "$CI_BUILD_REF"
    - cd eb
    - cat Dockerrun.aws.json.template | envsubst > Dockerrun.aws.json
    - git add Dockerrun.aws.json
    - eb deploy --staged
    - cd ../ && EXIT_STATUS=$? scripts/to_slack.sh
  variables:
    ENVIRONMENT: production
    APP_VERSION: "production-b$CI_PIPELINE_ID"
    GIT_STRATEGY: clone
  environment:
    name: production
    url: https://production.tastie.me
  when: manual
  only:
    - production
